#include "pch.h"

#include "Patcher.h"

#include <ext/Patching.h>
#include <ext/SKSEMessagingHandler.h>

#include "code.h"

namespace smp
{
	Patcher Patcher::m_Instance;

	void Patcher::Sink()
	{
		SKSEMessagingHandler::GetSingleton().AddSink(this);
	}

	using vp_t = BOOL(WINAPI*)(
		_In_ LPVOID  lpAddress,
		_In_ SIZE_T  dwSize,
		_In_ DWORD   flNewProtect,
		_Out_ PDWORD lpflOldProtect);

	static vp_t GetVirtualProtect()
	{
		if (auto h = GetModuleHandleA("kernel32.dll"))
		{
			return reinterpret_cast<vp_t>(GetProcAddress(h, "VirtualProtect"));
		}
		else
		{
			return nullptr;
		}
	}

	void Patcher::Run()
	{
		auto handle = DllGetHandleAndValidate();
		if (!handle)
		{
			return;
		}

		auto base = reinterpret_cast<std::uintptr_t>(handle);

		auto oper_del_addr = base + OPERATOR_DELETE_RVA;

		if (!Patching::validate_mem(oper_del_addr, { 0xE9, 0x8F, 0x0E, 0x00, 0x00 }))
		{
			gLog.FatalError("operator delete validation failed");
			return;
		}

		skee_operator_delete = oper_del_addr;

		/* this lunacy prevents false positives from some particularly idiotic AV software
		
			apparently VirtualProtect calls without much else in the binary are enough to flag it as malicious
		*/
		auto vprotect = GetVirtualProtect();
		if (!vprotect)
		{
			gLog.FatalError("runtime error");
			return;
		}

		auto target_addr = base + NIOVTaskDeferredMask_VTBL_RVA + sizeof(std::uintptr_t);

		gLog.Message("detouring NIOVTaskDeferredMask::Dispose @%.16llX", target_addr);

		DWORD oldProtect;

		auto v = std::uintptr_t(NIOVTaskDeferredMask_Dispose);

		vprotect(
			reinterpret_cast<void*>(target_addr),
			sizeof(v),
			PAGE_EXECUTE_READWRITE,
			std::addressof(oldProtect));

		reinterpret_cast<std::uintptr_t*>(target_addr)[0] = v;

		vprotect(
			reinterpret_cast<void*>(target_addr),
			sizeof(v),
			oldProtect,
			std::addressof(oldProtect));

		gLog.Message("patching successful");
	}

	HMODULE Patcher::DllGetHandleAndValidate()
	{
		auto handle = GetModuleHandleA("skee64.dll");
		if (!handle)
		{
			gLog.Error("%s: couldn't get skee64 module handle (probably not loaded)", __FUNCTION__);
			return nullptr;
		}

		MODULEINFO mi{};

		if (GetModuleInformation(
				GetCurrentProcess(),
				handle,
				std::addressof(mi),
				sizeof(MODULEINFO)) != TRUE)
		{
			gLog.Error("%s: GetModuleInformation failed", __FUNCTION__);
			return nullptr;
		}

		if (mi.SizeOfImage != EXPECTED_IMAGE_SIZE)
		{
			gLog.Error("%s: unexpected image size", __FUNCTION__);
			return nullptr;
		}

		auto base = reinterpret_cast<std::uintptr_t>(handle);

		auto vtbl_addr = reinterpret_cast<std::uintptr_t*>(base + NIOVTaskDeferredMask_VTBL_RVA);

		auto run_addr     = vtbl_addr[0];
		auto dispose_addr = vtbl_addr[1];

		if (run_addr - base != NIOVTaskDeferredMask_Run_RVA ||
		    dispose_addr - base != NIOVTaskDeferredMask_Dispose_RVA)
		{
			gLog.Error("%s: unexpected vfuncs", __FUNCTION__);
			return nullptr;
		}

		// clang-format off

		constexpr std::uint8_t rb[] = {
			0x48, 0x89, 0x5C, 0x24, 0x10, 0x48, 0x89, 0x6C, 0x24, 0x18, 0x56, 0x57, 0x41, 0x56, 0x48, 0x81,
			0xEC, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD9, 0x8B, 0x49, 0x0C, 0xFF, 0x15, 0xE7, 0xB7, 0x0E,
			0x00, 0x8B, 0x4B, 0x10, 0x48, 0x8B, 0xF0, 0xFF, 0x15, 0xDB, 0xB7, 0x0E, 0x00, 0x8B, 0x4B, 0x14,
			0x45, 0x33, 0xF6, 0x48, 0x8B, 0xE8, 0x85, 0xC9, 0x74, 0x0B, 0xFF, 0x15, 0xC8, 0xB7, 0x0E, 0x00,
			0x48, 0x8B, 0xF8, 0xEB, 0x03, 0x49, 0x8B, 0xFE, 0x48, 0x85, 0xF6, 0x0F, 0x84, 0x06, 0x01, 0x00,
			0x00, 0x48, 0x85, 0xED, 0x0F, 0x84, 0xFD, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x05, 0xFF, 0xB0, 0x0E,
			0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCE, 0x44, 0x89, 0x74, 0x24, 0x20, 0x4C, 0x8D, 0x80, 0x30, 0x0E,
			0xE1, 0x01, 0x4C, 0x8D, 0x88, 0x98, 0x37, 0xE1, 0x01, 0xFF, 0x15, 0x81, 0xB7, 0x0E, 0x00, 0x48,
			0x8B, 0x0D, 0xDA, 0xB0, 0x0E, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xF0, 0x44, 0x89, 0x74, 0x24, 0x20,
			0x4C, 0x8D, 0x81, 0x30, 0x0E, 0xE1, 0x01, 0x4C, 0x8D, 0x89, 0xC0, 0x53, 0xE1, 0x01, 0x48, 0x8B,
			0xCD, 0xFF, 0x15, 0x59, 0xB7, 0x0E, 0x00, 0x48, 0x8B, 0xE8, 0x48, 0x85, 0xFF, 0x74, 0x2A, 0x48,
			0x8B, 0x0D, 0xAA, 0xB0, 0x0E, 0x00, 0x33, 0xD2, 0x44, 0x89, 0x74, 0x24, 0x20, 0x4C, 0x8D, 0x81,
			0x30, 0x0E, 0xE1, 0x01, 0x4C, 0x8D, 0x89, 0x58, 0x90, 0xE1, 0x01, 0x48, 0x8B, 0xCF, 0xFF, 0x15,
			0x2C, 0xB7, 0x0E, 0x00, 0x48, 0x8B, 0xD0, 0xEB, 0x03, 0x49, 0x8B, 0xD6, 0x48, 0x85, 0xF6, 0x74,
			0x76, 0x48, 0x85, 0xED, 0x74, 0x71, 0x48, 0x8B, 0x4B, 0x28, 0x0F, 0x57, 0xC0, 0x4C, 0x89, 0xB4,
			0x24, 0x98, 0x00, 0x00, 0x00, 0xF3, 0x0F, 0x7F, 0x44, 0x24, 0x50, 0x48, 0x85, 0xC9, 0x74, 0x08,
			0xF0, 0xFF, 0x41, 0x08, 0x48, 0x8B, 0x4B, 0x28, 0x48, 0x8B, 0x43, 0x20, 0x4C, 0x8B, 0xCD, 0x44,
			0x0F, 0xB6, 0x43, 0x08, 0x48, 0x89, 0x44, 0x24, 0x50, 0x48, 0x8D, 0x44, 0x24, 0x60, 0x48, 0x89,
			0x44, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x50, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x8B, 0x43,
			0x18, 0xC7, 0x44, 0x24, 0x30, 0x03, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x28, 0x48, 0x89,
			0x54, 0x24, 0x20, 0x48, 0x8B, 0xD6, 0x48, 0x89, 0x4C, 0x24, 0x58, 0x48, 0x8D, 0x0D, 0x4E, 0xB5,
			0x0E, 0x00, 0xE8, 0x19, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x9C, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x49,
			0x8B, 0x5B, 0x28, 0x49, 0x8B, 0x6B, 0x30, 0x49, 0x8B, 0xE3, 0x41, 0x5E, 0x5F, 0x5E, 0xC3
		};

		// clang-format on

		if (!Patching::validate_mem(run_addr, rb) ||
		    !Patching::validate_mem(dispose_addr, { 0xC2, 0x00, 0x00 }))
		{
			gLog.Error("%s: NIOVTaskDeferredMask vfunc validation failed", __FUNCTION__);
			return nullptr;
		}

		return handle;
	}

	void Patcher::Receive(const SKSEMessagingEvent& a_evn)
	{
		switch (a_evn.message->type)
		{
		case SKSEMessagingInterface::kMessage_PostLoad:
			Run();
			gLog.Close();
			break;
		}
	}
}